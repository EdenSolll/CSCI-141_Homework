def merge_sort_dataclass(x):
    if len(x) < 2:
        return x
    result = []
    y = merge_sort_dataclass(x[: len(x) // 2])
    z = merge_sort_dataclass(x[len(x) // 2 :])
    i = 0
    j = 0
    while i < len(y) and j < len(z):
        if y[i].space_remaining > z[j].space_remaining:
            result.append(z[j])
            j += 1
        else:
            result.append(y[i])
            i += 1
    result += y[i:]
    result += z[j:]
    return result

"""
This is a merge sort algorithm that will sort a list of classes (e.x)

box1 = Box("box1", 5, [])
box2 = Box("box2", 10, [])
box3 = Box("box3", 15, [])

list_of_boxes = [box1, box2, box3]

If you use this strategy you will want to replace .space_remaining with
whatever you called your dataclass property that you want to sort by.
"""


def insertion_sort_dict_by_value(input_dict):
    items = list(input_dict.items())

    for i in range(1, len(items)):
        key = items[i]
        j = i - 1
        while j >= 0 and key[1] < items[j][1]:
            items[j + 1] = items[j]
            j -= 1
        items[j + 1] = key

    return dict(items)

"""
This is a insertion sort algorithm that will return a dictionary sorted based on
it's values.
"""

list_of_boxes.sort(key=lambda x: x.weight, reverse=True)

"""
This is a strategy of sorting a list of dataclasses based on a property value,
just change .weight to be whatever to sort your dataclasses by.
"""

sorted_weights = dict(sorted(items_and_weight.items(), key=lambda item: item[1], reverse=True))

"""
This is a strategy of sorting a dictionary based on values using sorted instead of an algorithm
"""
